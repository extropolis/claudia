import { EventEmitter } from 'events';
import { v4 as uuid } from 'uuid';
import { Plan, PlanItem, ChatMessage, Task } from '@claudia/shared';
import { TaskManager } from '../task-manager.js';
import { ProcessManager } from '../process-manager.js';
import { ConfigStore } from '../config-store.js';
import { ConversationStore } from '../conversation-store.js';
import { ProjectStore } from '../project-store.js';
import { generateMermaidDiagram, orderPlanItems, validatePlanDependencies } from '../plan-visualizer.js';

export interface PlanExecutorDependencies {
    taskManager: TaskManager;
    processManager: ProcessManager;
    configStore: ConfigStore;
    conversationStore: ConversationStore;
    projectStore: ProjectStore;
}

export class PlanExecutor extends EventEmitter {
    private currentPlan: Plan | null = null;
    private executingPlanId: string | null = null;
    private planTaskIds: Set<string> = new Set();
    private autoApproveEnabled: boolean = false;
    private dependencies: PlanExecutorDependencies;
    private currentWorkspaceId: string | null = null;

    constructor(dependencies: PlanExecutorDependencies) {
        super();
        this.dependencies = dependencies;
    }

    setWorkspaceId(workspaceId: string | null) {
        this.currentWorkspaceId = workspaceId;
    }

    setAutoApproveEnabled(enabled: boolean): void {
        this.autoApproveEnabled = enabled;
    }

    getCurrentPlan(): Plan | null {
        return this.currentPlan;
    }

    /**
     * Handle a plan generated by the AI
     */
    async handlePlan(planItems: any[]): Promise<void> {
        // Get the user request from current conversation
        const conversationStore = this.dependencies.conversationStore;
        const currentConvId = conversationStore.getCurrentId();
        const conversation = currentConvId ? conversationStore.getConversation(currentConvId) : null;
        const lastUserMessage = conversation?.chatHistory
            .slice()
            .reverse()
            .find((m: ChatMessage) => m.role === 'user');

        const plan: Plan = {
            id: uuid(),
            status: 'pending',
            items: planItems.map(item => ({
                id: uuid(),
                name: item.name,
                description: item.description,
                testingStrategy: item.testingStrategy || 'Verify the task completes successfully',
                dependsOn: item.dependsOn || []
            })),
            userRequest: lastUserMessage?.content || '',
            createdAt: new Date()
        };

        // Validate dependencies
        const validation = validatePlanDependencies(plan.items);
        if (!validation.valid) {
            console.error(`[PlanExecutor] Invalid plan dependencies: ${validation.error}`);
            const errorMessage: ChatMessage = {
                id: uuid(),
                role: 'assistant',
                content: `‚ùå Plan validation failed: ${validation.error}. Please try again.`,
                timestamp: new Date()
            };
            this.emit('chat', errorMessage);
            return;
        }

        // Generate mermaid diagram
        const mermaidDiagram = generateMermaidDiagram(plan.items);

        // Show the plan with mermaid diagram
        let planMessage = `üìã I've created a plan with ${plan.items.length} task(s):\n\n`;

        if (mermaidDiagram) {
            planMessage += '```mermaid\n' + mermaidDiagram + '\n```\n\n';
        }

        // Order tasks by dependencies for display
        const orderedItems = orderPlanItems(plan.items);
        planMessage += orderedItems.map((item, i) => {
            const deps = item.dependsOn && item.dependsOn.length > 0
                ? `\n   *Depends on: ${item.dependsOn.map(id => plan.items.find(p => p.id === id)?.name || id).join(', ')}*`
                : '';
            return `**${i + 1}. ${item.name}**\n${item.description}\nüß™ *Testing: ${item.testingStrategy}*${deps}`;
        }).join('\n\n');

        const message: ChatMessage = {
            id: uuid(),
            role: 'assistant',
            content: planMessage,
            timestamp: new Date()
        };
        this.emit('chat', message);

        this.currentPlan = plan;
        this.emit('plan:created', { plan });

        if (this.autoApproveEnabled) {
            await this.approvePlan();
        }
    }

    /**
     * Approve the current plan and execute all tasks
     */
    async approvePlan(): Promise<void> {
        if (!this.currentPlan || this.currentPlan.status !== 'pending') {
            console.log('[PlanExecutor] No pending plan to approve');
            return;
        }

        console.log(`[PlanExecutor] Approving plan ${this.currentPlan.id}`);
        this.currentPlan.status = 'executing';
        this.executingPlanId = this.currentPlan.id;
        this.emit('plan:approved', { planId: this.currentPlan.id });

        // Emit approval message
        const approvalMessage: ChatMessage = {
            id: uuid(),
            role: 'assistant',
            content: `‚úÖ Plan approved! Starting ${this.currentPlan.items.length} task(s)...`,
            timestamp: new Date()
        };
        this.emit('chat', approvalMessage);

        // Order plan items by dependencies
        const orderedItems = orderPlanItems(this.currentPlan.items);

        // Create task ID mapping from plan items
        const planItemToTaskId = new Map<string, string>();

        // Execute all plan items in dependency order
        // Use current workspace path if set, otherwise fall back to project store
        const cwd = this.currentWorkspaceId || this.dependencies.projectStore.getCurrentProject() || undefined;
        const mcpServers = this.dependencies.configStore.getMCPServers();
        const taskManager = this.dependencies.taskManager;
        const processManager = this.dependencies.processManager;

        // Note: For now we spawn all tasks, but `taskManager` handles dependency blocking
        // Real sequential execution relies on the task manager respecting dependencies
        for (const item of orderedItems) {
            const task = taskManager.createTask(item.name, item.description, undefined, cwd);

            // Track this task as part of the plan
            this.planTaskIds.add(task.id);
            planItemToTaskId.set(item.id, task.id);

            // Set up task dependencies if present
            if (item.dependsOn && item.dependsOn.length > 0) {
                const dependentTaskIds = item.dependsOn
                    .map(depPlanItemId => planItemToTaskId.get(depPlanItemId))
                    .filter(id => id !== undefined) as string[];

                if (dependentTaskIds.length > 0) {
                    task.dependsOn = dependentTaskIds;
                }
            }

            // Build simple prompt - ideally this should be delegated to a prompt service
            // but we'll inline it for now to avoid circular dependency
            const workerPrompt = item.description;

            // Note: In original Orchestrator, buildWorkerPrompt was called. 
            // We'll trust that ProcessManager or TaskManager handles this or we need to pass a prompt builder.
            // For now, assuming description is enough or we improve this later.

            const worker = await processManager.spawn(task.id, workerPrompt, cwd, mcpServers);
            taskManager.assignWorker(task.id, worker.id);

            console.log(`[PlanExecutor] Started task: ${item.name}${cwd ? ` in ${cwd}` : ''}`);
        }

        // Clear the current plan (but keep tracking executingPlanId for summary)
        this.currentPlan = null;
    }

    /**
     * Reject the current plan
     */
    async rejectPlan(): Promise<void> {
        if (!this.currentPlan || this.currentPlan.status !== 'pending') {
            return;
        }

        console.log(`[PlanExecutor] Rejecting plan ${this.currentPlan.id}`);
        this.emit('plan:rejected', { planId: this.currentPlan.id });
        this.currentPlan = null;

        // Emit rejection message asking for clarification
        const rejectionMessage: ChatMessage = {
            id: uuid(),
            role: 'assistant',
            content: `‚ùå Plan cancelled. Would you like to modify your request or try something different?`,
            timestamp: new Date()
        };
        this.emit('chat', rejectionMessage);
    }

    /**
     * Check if all plan tasks are complete and generate summary
     */
    async checkCompletion(): Promise<void> {
        if (!this.executingPlanId || this.planTaskIds.size === 0) {
            return;
        }

        const taskManager = this.dependencies.taskManager;
        const allComplete = Array.from(this.planTaskIds).every(taskId => {
            const task = taskManager.getTask(taskId);
            return task && (task.status === 'complete' || task.status === 'error');
        });

        if (!allComplete) {
            return;
        }

        // Generate final summary
        const tasks = Array.from(this.planTaskIds).map(id => taskManager.getTask(id)).filter(t => t) as Task[];
        const completedCount = tasks.filter(t => t.status === 'complete').length;
        const errorCount = tasks.filter(t => t.status === 'error').length;

        let summaryContent = `\n\n---\n\n## üìä Plan Execution Complete\n\n`;
        summaryContent += `**Results**: ${completedCount} completed, ${errorCount} failed\n\n`;

        summaryContent += `**Tasks:**\n`;
        tasks.forEach((task, i) => {
            const statusEmoji = task.status === 'complete' ? '‚úÖ' : '‚ùå';
            summaryContent += `${i + 1}. ${statusEmoji} ${task.name}`;
            if (task.structuredResult?.summary) {
                summaryContent += ` - ${task.structuredResult.summary}`;
            }
            summaryContent += '\n';
        });

        // Extract artifacts
        const allArtifacts: string[] = [];
        for (const task of tasks) {
            if (task.structuredResult?.artifacts) {
                allArtifacts.push(...task.structuredResult.artifacts);
            }
        }

        if (allArtifacts.length > 0) {
            summaryContent += `\n**Artifacts created:**\n`;
            const uniqueArtifacts = Array.from(new Set(allArtifacts));
            uniqueArtifacts.forEach(artifact => {
                summaryContent += `- ${artifact}\n`;
            });
        }

        const summaryMessage: ChatMessage = {
            id: uuid(),
            role: 'assistant',
            content: summaryContent,
            timestamp: new Date()
        };
        this.emit('chat', summaryMessage);

        // Clean up
        this.executingPlanId = null;
        this.planTaskIds.clear();
    }
}
